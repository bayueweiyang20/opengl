# 坐标系统
局部空间、世界空间、视觉空间、裁剪空间、屏幕空间五个状态。  
![Alt text](./images/coordinate_systems.png)  
1. 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。
2. 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。
3. 接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。
4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。
5. 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。
我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。  
局部空间：物体所占用的坐标边界所围成的空间。  
世界空间：局部空间通过使用模型矩阵变换而来。  
观察矩阵：相当于有了一个摄像机观察世界空间，用到观察矩阵。  
裁剪空间：顾名思义，裁掉范围之外的点，显示剩余的点。用到投影矩阵，有两种投影方式：正视投影、透视投影，后者更接近于眼睛所看到的世界（近大远小，比如火车轨道），有个梗（鸽子为什么这么大）就是因为这个原理。  
最后三个矩阵和原本的坐标运算时注意顺序。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。  
  
# 3D显示
1. 首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。
2. 接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的。将摄像机向后移动，和将整个场景向前移动是一样的。（右手系）
3. 最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影。
4. 既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标，然后我们将矩阵传入着色器。

# 更加3D
拓展我们的2D平面到3D需要更多的顶点，这里我们渲染一个正方体需要36个顶点。成功渲染出一个正方体，但是由于渲染时会有非常混乱的覆盖关系，导致显示起来怪怪的，这时候我们运用z缓冲（深度缓冲），它允许OpenGL决定何时覆盖一个像素而何时不覆盖。  
我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的，通过glEnable函数来开启深度测试。因为我们使用了深度测试，我们也要在每次渲染迭代之前清除深度缓冲。  
